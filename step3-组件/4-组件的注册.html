<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./vue.js"></script>
</head>
<body>
    <div id="app">
        <component-a></component-a>
    </div>

    <script>
        /***
         * Vue.component('', {}) 注册都是全局组件
        */
       /***
        * 局部注册
       */
        const ComponentA = {
            template: 'today is new day'
        }

        const ComponentB = {
            template: 'today is bad day'
        }
        
        /**
         * 组件的Prop: 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：
         * 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。
         * */ 
        /***
         * 1.这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 
         * 数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
        */
       /***
        *   props: ['initialCounter'],
            data: function () {
            return {
                counter: this.initialCounter
            }
            }
       */
      /***
       * 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的
       * 值来定义一个计算属性：
       *    props: ['size'],
            computed: {
            normalizedSize: function () {
                return this.size.trim().toLowerCase()
            }
            }
       * 
      */

      /***
       * 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，
       * 在子组件中改变这个对象或数组本身将会影响到父组件的状态。
      */
        const vm = new Vue({
            el: '#app',
            data: {

            },
            components: {
                'component-a': ComponentA,
                'component-b': ComponentB    
            }
        })
        
         
    </script>
</body>
</html>